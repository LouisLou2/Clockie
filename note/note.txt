1. Hive的box每次open是需要重新复制的，原先引用变量引用的对象已经不存在了


2. 注意到我在AlarmPage和WorldClockPage都用了with AutomaticKeepAliveClientMixin
@override
bool get wantKeepAlive => true;

super.build(context);
其实四个tab页面都不用也没关系，但是AlarmPage和WorldClockPage渲染更复杂，这样可以在内存中驻留(转到其他tab不会调用原先界面的dispose方法);
但是此方法不能滥用，会造成内存占用多的问题。

3. tab的转换默认会引起原tab的dispose，但是通过路由转到其他界面，并不会引起原页面dispose

4. 一个流默认只能会一个监听者监听，否则会异常，如果需要共享一个流，应该用广播流

5. 注意异步操作的顺序性，有些操作即使是异步，也讲究顺序，合理利用async和await
6. Flutter有顽疾：数据本来应该直接可以在外部修改，然后最后Hive.close()来将数据持久化，不用每次修改都调用put()，但是Flutter appLifecycleState.detached在退出应用时就是不出现,所以没办法监听将要退出的时刻，所以才要每次都调用put()，来强制持久化，这正是顽疾所在。
7.//因为我发现，当应用在后台运行时，一个一个的流是正常还在运行的，但是会出现即使流到了，订阅这个流的StringBuilder并不刷新，好像在后台时就忽略这些流信号
  //这会出现一个状况就是，只能等到我再次进入应用起的下一个流信号(进入下一个分钟)才会刷新，这样就会出现一分钟之内不等的沉默
  //这里加一个now.minute!=prevMin就是为了解决这个问题，这样再次进入应用，发现与之前记录的分钟不一样，也要发出刷新信号
  //不要以为小时和天就不用这么做了，因为这个问题也会出现在小时和天上，设想一下，我在跨越小时的时候仍把它放在后台，
  // 这样下一次刷新只能等到我再次进入应用起的下一个小时，这甚至更糟糕
  //但是只判断分钟是不够的，万一出现13:13离去但是14:13回来的情况，这是时就失效了，
  // 所以还要加上不断地进一步判断，但是还好，dart具有短路求值的特性，大概率在前面就已经判断出来了
  //并且我想用户也不会太长时间将他放在后台，这只是万无一失的保险

  //以上内容还是放弃了，现在我又想了一下，我还是不要在流上做手脚了，还是每次从后台进入前台时，刷新一下就好了，不要太复杂了，其实更多原因(因为判断条件太多了，浪费)
7.还有其他知识在ipad上记录